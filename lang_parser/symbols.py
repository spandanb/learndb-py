from __future__ import annotations
import os
from lark import Lark, logger, ast_utils, Transformer, v_args, Token, Tree
from typing import Any, List, Union
from dataclasses import dataclass
from enum import Enum, auto
from .visitor import Visitor
from .utils import camel_to_snake

# logger.setLevel(logging.DEBUG)


WHITESPACE = ' '


class JoinType(Enum):
    Inner = auto()
    LeftOuter = auto()
    RightOuter = auto()
    FullOuter = auto()
    Cross = auto()


class DataType(Enum):
    """
    Enums for system datatypes
    """
    Integer = auto()
    Text = auto()
    Real = auto()
    Blob = auto()


def unwrap_tree_atom(rule: Tree):
    # unwrap a tree object into a literal value
    # by unpacking Tree. The Tree might contain a child Token (has data attribute)
    # or another AST class. We want to pick the least encapsulated.
    assert len(rule.children) == 1, f"expected single child; found {len(rule.children)}"
    child = rule.children[0]
    return getattr(child, "value", child)


def unwrap_tree_list(rule: Tree):
    # NOTE: child or child.value
    return [getattr(child, "value", child) for child in rule.children]


class _Symbol(ast_utils.Ast):
    """
    The root of AST hierarchy
    """
    # NOTE: classes with preceding "_" will be skipped

    def accept(self, visitor: Visitor) -> Any:
        return visitor.visit(self)

    @property
    def data(self):
        # pretend to be a tree
        value = camel_to_snake(self.__class__.__name__)
        return Token(None, value)

    def is_virtual(self) -> bool:
        """
        Helper method to determine whether symbol/parsed
        rules' class is virtual, i.e. won't be materialized.
        Classes whose names begins with "_" are virtual.
        :return:
        """
        classname = self.__class__.__name__
        return classname.startswith("_")

    def get_prettychild(self, child, child_depth) -> list:
        """
        Get pretty printed child; calls different method depending on whether
        child is derived from _Symbol, Lark.Tree, or Lark.Token.

        :param child:
        :param child_depth:
        :return:
        """
        if hasattr(child, "prettyprint"):
            # part of Ast hierarchy
            val = child.prettyprint(depth=child_depth)
        elif hasattr(child, "pretty"):
            # part of autogenerated hierarchy
            preceding = WHITESPACE * child_depth
            formatted = f"{preceding}{child.pretty(preceding)}"
            val = [formatted]
        else:
            # token
            preceding = WHITESPACE * child_depth
            formatted = f"{preceding}{str(child)}"
            val = [formatted]
        return val

    def prettyprint(self, depth=0) -> List:
        """
        return a pretty printed string
        :return:
        """
        if hasattr(self, "asdict"):
            children = self.asdict()
        else:
            children = {key: getattr(self, key)
                        for key in dir(self)
                        if (not key.startswith("_") and not callable(getattr(self, key)))}
        lines = []

        child_depth = depth if self.is_virtual() else depth + 1
        preceding = WHITESPACE * depth
        if not self.is_virtual():
            classname = self.__class__.__name__
            lines.append(f'{preceding}{classname}:{os.linesep}')

        for key, value in children.items():
            child = getattr(self, key)
            if isinstance(child, list):
                # list
                for element in child:
                    lines.extend(self.get_prettychild(element, child_depth))
            else:
                # scalar
                lines.extend(self.get_prettychild(child, child_depth))

        return lines

    def prettystr(self) -> str:
        return "".join(self.prettyprint())


@dataclass
class Program(_Symbol, ast_utils.AsList):
    statements: List[_Stmnt]


#class Program(_Symbol, ast_utils.AsList):
#    def __init__(self, statements):
#        self.statements = statements


# is this even needed?
class _Stmnt(_Symbol):
    pass


@dataclass
class SelectStmnt(_Stmnt):
    select_clause: _Selectables
    from_clause: FromClause = None
    group_by_clause: Any = None
    having_clause: Any = None
    order_by_clause: Any = None
    limit_clause: Any = None


#@dataclass
#class Selectables(_Symbol,  ast_utils.AsList):
#    selections: List[Selectable]

@dataclass
class SelectClause(_Symbol,  ast_utils.AsList):
    selections: List[Selectable]


@dataclass
class Selectable(_Symbol):
    item: Any


#class SelectClause(_Symbol):



@dataclass
class FromClause(_Symbol):
    source: Any
    # where clauses is nested in from, i.e. in a select
    # a where clause without a from clause is invalid
    where_clause: Any = None


@dataclass
class SingleSource(_Symbol):
    table_name: Any
    table_alias: Any = None


class UnconditionedJoin(_Symbol):
    def __init__(self, source=None, other_source=None):
        self.left_source = source
        self.right_source = other_source
        self.join_type = JoinType.Cross


class CreateStmnt(_Symbol):
    def __init__(self, table_name: Tree = None, column_def_list: Tree = None):
        self.table_name = unwrap_tree_atom(table_name)
        self.columns = unwrap_tree_list(column_def_list)  # todo: this unwrapping may be unnecessary
        self.validate()

    def validate(self):
        """
        Ensure one and only one primary key
        """
        pkey_count = len([col for col in self.columns if col.is_primary_key])
        if pkey_count != 1:
            raise ValueError(f"Expected 1 primary key received {pkey_count}")

    def __repr__(self):
        return str(self)

    def __str__(self):
        return f'{self.__class__.__name__}({self.__dict__})'


@dataclass
class _ColumnDefList(_Symbol, ast_utils.AsList):
    column_defs: List[Any]


@dataclass
class InsertStmnt(_Symbol):
    table_name: Any
    column_name_list: ColumnNameList
    value_list: ValueList


@dataclass
class _ColumnNameList(_Symbol, ast_utils.AsList):
    column_names: List[Any]


@dataclass
class _ValueList(_Symbol, ast_utils.AsList):
    values: List[Any]